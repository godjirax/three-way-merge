export default class HeckelDiff {
    constructor(left, right) {
        this.left = left;
        this.right = right;
    }
    static executeDiff(oldTextArray, newTextArray) {
        if (!oldTextArray.push) {
            throw (new Error('Argument is not an array'));
        }
        const diffResult = HeckelDiff.diff(oldTextArray, newTextArray);
        return new HeckelDiffWrapper(oldTextArray, newTextArray, diffResult).convertToTypedOutput();
    }
    static diff(left, right) {
        const differ = new HeckelDiff(left, right);
        return differ.performDiff();
    }
    performDiff() {
        let uniquePositions = this.identifyUniquePositions();
        uniquePositions.sort((a, b) => b[0] - a[0]);
        const [leftChangePos, rightChangePos] = this.findNextChange();
        let initChanges = new ChangeData(leftChangePos, rightChangePos, []);
        uniquePositions.forEach((pos) => {
            initChanges = this.getDifferences(initChanges, pos);
        });
        return initChanges.changeRanges;
    }
    getDifferences(changeData, uniquePositions) {
        const [leftPos, rightPos] = [changeData.leftChangePos,
            changeData.rightChangePos];
        const [leftUniqPos, rightUniqPos] = uniquePositions;
        if (leftUniqPos < leftPos || rightUniqPos < rightPos) {
            return changeData;
        }
        else {
            const [leftLo, leftHi, rightLo, rightHi] = this.findPrevChange(leftPos, rightPos, leftUniqPos - 1, rightUniqPos - 1);
            const [nextLeftPos, nextRightPos] = this.findNextChange(leftUniqPos + 1, rightUniqPos + 1);
            const updatedRanges = this.appendChangeRange(changeData.changeRanges, leftLo, leftHi, rightLo, rightHi);
            return new ChangeData(nextLeftPos, nextRightPos, updatedRanges);
        }
    }
    findNextChange(leftStartPos = 0, rightStartPos = 0) {
        const lArr = this.left.slice(leftStartPos) || [];
        const rArr = this.right.slice(rightStartPos) || [];
        const offset = this.mismatchOffset(lArr, rArr);
        return [leftStartPos + offset, rightStartPos + offset];
    }
    findPrevChange(leftLo, rightLo, leftHi, rightHi) {
        if (leftLo > leftHi || rightLo > rightHi) {
            return [leftLo, leftHi, rightLo, rightHi];
        }
        else {
            const lArr = this.left.slice(leftLo, leftHi + 1).reverse() || [];
            const rArr = this.right.slice(rightLo, rightHi + 1).reverse() || [];
            const offset = this.mismatchOffset(lArr, rArr);
            return [leftLo, leftHi - offset, rightLo, rightHi - offset];
        }
    }
    mismatchOffset(lArr, rArr) {
        const max = Math.max(lArr.length, rArr.length);
        for (let i = 0; i < max; i++) {
            if (lArr[i] !== rArr[i]) {
                return i;
            }
        }
        return Math.min(lArr.length, rArr.length);
    }
    identifyUniquePositions() {
        const leftUniques = this.findUnique(this.left);
        const rightUniques = this.findUnique(this.right);
        const leftKeys = new Set(...leftUniques.keys());
        const rightKeys = new Set(...rightUniques.keys());
        const sharedKeys = new Set([...leftKeys].filter(k => rightKeys.has(k)));
        const uniqRanges = [...sharedKeys].map((k) => {
            return [leftUniques.get(k),
                rightUniques.get(k)];
        });
        uniqRanges.unshift([this.left.length, this.right.length]);
        return uniqRanges;
    }
    findUnique(array) {
        const flaggedUniques = new Map();
        array.forEach((item, pos) => {
            flaggedUniques.set(item, new UniqueItem(pos, !flaggedUniques.has(item)));
        });
        const uniques = new Map();
        for (let [key, value] of flaggedUniques.entries()) {
            if (value.unique) {
                uniques.set(key, value.pos);
            }
        }
        return uniques;
    }
    // given the calculated bounds of the 2 way diff, create the proper
    // change type and add it to the queue.
    appendChangeRange(changesRanges, leftLo, leftHi, rightLo, rightHi) {
        if (leftLo <= leftHi && rightLo <= rightHi) {
            // for this change, the bounds are both 'normal'. the beginning
            // of the change is before the end.
            changesRanges.push(new ChangeRange(Action.change, leftLo + 1, leftHi + 1, rightLo + 1, rightHi + 1));
        }
        else if (leftLo <= leftHi) {
            changesRanges.push(new ChangeRange(Action.remove, leftLo + 1, leftHi + 1, rightLo + 1, rightLo));
        }
        else if (rightLo <= rightHi) {
            changesRanges.push(new ChangeRange(Action.add, leftLo + 1, leftLo, rightLo + 1, rightHi + 1));
        }
        return changesRanges;
    }
}
class UniqueItem {
    constructor(pos, unique) {
        this.pos = pos;
        this.unique = unique;
    }
}
export class TextNode {
    constructor(text, low) {
        this.text = text;
        this.low = low;
    }
}
class HeckelDiffWrapper {
    constructor(oldTextArray, newTextArray, chunks) {
        this.oldTextArray = oldTextArray;
        this.newTextArray = newTextArray;
        this.chunks = chunks;
        this.oldText = [];
        this.newText = [];
    }
    convertToTypedOutput() {
        let finalIndexes = new IndexTracker(0, 0);
        this.chunks.forEach((chunk) => {
            const [oldIteration, newIteration] = this.setTextNodeIndexes(chunk, finalIndexes.oldIndex, finalIndexes.newIndex);
            const [oldIndex, newIndex] = this.appendChanges(chunk, finalIndexes.oldIndex + oldIteration, finalIndexes.newIndex + newIteration);
            finalIndexes.oldIndex = oldIndex;
            finalIndexes.newIndex = newIndex;
        });
        this.setTheRemainingTextNodeIndexes(finalIndexes.oldIndex, finalIndexes.newIndex);
        return {
            oldText: this.oldText,
            newText: this.newText
        };
    }
    setTextNodeIndexes(chunk, oldIndex, newIndex) {
        let oldIteration = 0;
        while (oldIndex + oldIteration < chunk.leftLo - 1) { // chunk indexes from 1
            this.oldText.push(new TextNode(this.oldTextArray[oldIndex + oldIteration], newIndex + oldIteration));
            oldIteration += 1;
        }
        let newIteration = 0;
        while (newIndex + newIteration < chunk.rightLo - 1) {
            this.newText.push(new TextNode(this.newTextArray[newIndex + newIteration], oldIndex + newIteration));
            newIteration += 1;
        }
        return [oldIteration, newIteration];
    }
    appendChanges(chunk, oldIndex, newIndex) {
        while (oldIndex <= chunk.leftHi - 1) {
            this.oldText.push(this.oldTextArray[oldIndex]);
            oldIndex += 1;
        }
        while (newIndex <= chunk.rightHi - 1) {
            this.newText.push(this.newTextArray[newIndex]);
            newIndex += 1;
        }
        return [oldIndex, newIndex];
    }
    setTheRemainingTextNodeIndexes(oldIndex, newIndex) {
        let iteration = 0;
        while (oldIndex + iteration < this.oldTextArray.length) {
            this.oldText.push(new TextNode(this.oldTextArray[oldIndex + iteration], newIndex + iteration));
            iteration += 1;
        }
        while (newIndex + iteration < this.newTextArray.length) {
            this.newText.push(new TextNode(this.newTextArray[newIndex + iteration], oldIndex + iteration));
            iteration += 1;
        }
    }
}
class IndexTracker {
    constructor(oldIndex, newIndex) {
        this.oldIndex = oldIndex;
        this.newIndex = newIndex;
    }
}
export var Action;
(function (Action) {
    Action["change"] = "change";
    Action["add"] = "add";
    Action["remove"] = "remove";
})(Action || (Action = {}));
export class ChangeRange {
    constructor(action, leftLo, leftHi, rightLo, rightHi) {
        this.action = action;
        this.leftLo = leftLo;
        this.leftHi = leftHi;
        this.rightLo = rightLo;
        this.rightHi = rightHi;
    }
}
export class ChangeData {
    constructor(leftChangePos, rightChangePos, changeRanges) {
        this.leftChangePos = leftChangePos;
        this.rightChangePos = rightChangePos;
        this.changeRanges = changeRanges;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVja2VsLWRpZmYuanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2tldmluL3RyYXZhaWwvZGV2eC90aHJlZS13YXktbWVyZ2UvIiwic291cmNlcyI6WyJoZWNrZWwtZGlmZi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLENBQUMsT0FBTztJQWdCWixZQUFtQixJQUFjLEVBQVMsS0FBZTtRQUF0QyxTQUFJLEdBQUosSUFBSSxDQUFVO1FBQVMsVUFBSyxHQUFMLEtBQUssQ0FBVTtJQUFHLENBQUM7SUFmN0QsTUFBTSxDQUFDLFdBQVcsQ0FBQyxZQUFzQixFQUFFLFlBQXNCO1FBQy9ELElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFO1lBQ3RCLE1BQUssQ0FBQyxJQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDLENBQUM7U0FDOUM7UUFFRCxNQUFNLFVBQVUsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQztRQUUvRCxPQUFPLElBQUksaUJBQWlCLENBQUMsWUFBWSxFQUFFLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO0lBQzlGLENBQUM7SUFFRCxNQUFNLENBQUMsSUFBSSxDQUFDLElBQWMsRUFBRSxLQUFlO1FBQ3pDLE1BQU0sTUFBTSxHQUFHLElBQUksVUFBVSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMzQyxPQUFPLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUM5QixDQUFDO0lBSUQsV0FBVztRQUNULElBQUksZUFBZSxHQUFHLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO1FBQ3JELGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFNUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxjQUFj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QU8sQ0FBUTtJQUFHLENBQUM7Q0FDL0Q7QUFFRCxNQUFNO0lBQ0osWUFBbUIsYUFBcUIsRUFDckIsY0FBc0IsRUFDdEIsWUFBMkI7UUFGM0Isa0JBQWEsR0FBYixhQUFhLENBQVE7UUFDckIsbUJBQWMsR0FBZCxjQUFjLENBQVE7UUFDdEIsaUJBQVksR0FBWixZQUFZLENBQWU7SUFDOUMsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVja2VsRGlmZiB7XG4gIHN0YXRpYyBleGVjdXRlRGlmZihvbGRUZXh0QXJyYXk6IHN0cmluZ1tdLCBuZXdUZXh0QXJyYXk6IHN0cmluZ1tdKSB7XG4gICAgaWYgKCFvbGRUZXh0QXJyYXkucHVzaCkge1xuICAgICAgdGhyb3cobmV3IEVycm9yKCdBcmd1bWVudCBpcyBub3QgYW4gYXJyYXknKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZGlmZlJlc3VsdCA9IEhlY2tlbERpZmYuZGlmZihvbGRUZXh0QXJyYXksIG5ld1RleHRBcnJheSk7XG5cbiAgICByZXR1cm4gbmV3IEhlY2tlbERpZmZXcmFwcGVyKG9sZFRleHRBcnJheSwgbmV3VGV4dEFycmF5LCBkaWZmUmVzdWx0KS5jb252ZXJ0VG9UeXBlZE91dHB1dCgpO1xuICB9XG5cbiAgc3RhdGljIGRpZmYobGVmdDogc3RyaW5nW10sIHJpZ2h0OiBzdHJpbmdbXSkge1xuICAgIGNvbnN0IGRpZmZlciA9IG5ldyBIZWNrZWxEaWZmKGxlZnQsIHJpZ2h0KTtcbiAgICByZXR1cm4gZGlmZmVyLnBlcmZvcm1EaWZmKCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbGVmdDogc3RyaW5nW10sIHB1YmxpYyByaWdodDogc3RyaW5nW10pIHt9XG5cbiAgcGVyZm9ybURpZmYoKSB7XG4gICAgbGV0IHVuaXF1ZVBvc2l0aW9ucyA9IHRoaXMuaWRlbnRpZnlVbmlxdWVQb3NpdGlvbnMoKTtcbiAgICB1bmlxdWVQb3NpdGlvbnMuc29ydCgoYSwgYikgPT4gYlswXSAtIGFbMF0pO1xuXG4gICAgY29uc3QgW2xlZnRDaGFuZ2VQb3MsIHJpZ2h0Q2hhbmdlUG9zXSA9IHRoaXMuZmluZE5leHRDaGFuZ2UoKTtcbiAgICBsZXQgaW5pdENoYW5nZXMgPSBuZXcgQ2hhbmdlRGF0YShsZWZ0Q2hhbmdlUG9zLCByaWdodENoYW5nZVBvcywgW10pO1xuICAgIHVuaXF1ZVBvc2l0aW9ucy5mb3JFYWNoKChwb3MpID0+IHtcbiAgICAgIGluaXRDaGFuZ2VzID0gdGhpcy5nZXREaWZmZXJlbmNlcyhpbml0Q2hhbmdlcywgcG9zKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBpbml0Q2hhbmdlcy5jaGFuZ2VSYW5nZXM7XG4gIH1cblxuICBnZXREaWZmZXJlbmNlcyhjaGFuZ2VEYXRhOiBDaGFuZ2VEYXRhLCB1bmlxdWVQb3NpdGlvbnM6IFVuaXF1ZVBvc2l0aW9ucykge1xuICAgIGNvbnN0IFtsZWZ0UG9zLCByaWdodFBvc10gPSBbY2hhbmdlRGF0YS5sZWZ0Q2hhbmdlUG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGF0YS5yaWdodENoYW5nZVBvc107XG4gICAgY29uc3QgW2xlZnRVbmlxUG9zLCByaWdodFVuaXFQb3NdID0gdW5pcXVlUG9zaXRpb25zO1xuXG4gICAgaWYgKGxlZnRVbmlxUG9zIDwgbGVmdFBvcyB8fCByaWdodFVuaXFQb3MgPCByaWdodFBvcykge1xuICAgICAgcmV0dXJuIGNoYW5nZURhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtsZWZ0TG8sIGxlZnRIaSxcbiAgICAgICAgICAgICByaWdodExvLCByaWdodEhpXSA9IHRoaXMuZmluZFByZXZDaGFuZ2UobGVmdFBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRQb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRVbmlxUG9zLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0VW5pcVBvcy0xKTtcbiAgICAgIGNvbnN0IFtuZXh0TGVmdFBvcyxcbiAgICAgICAgICAgICBuZXh0UmlnaHRQb3NdID0gdGhpcy5maW5kTmV4dENoYW5nZShsZWZ0VW5pcVBvcysxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0VW5pcVBvcysxKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRSYW5nZXMgPSB0aGlzLmFwcGVuZENoYW5nZVJhbmdlKGNoYW5nZURhdGEuY2hhbmdlUmFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdExvLCBsZWZ0SGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodExvLCByaWdodEhpKTtcbiAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGF0YShuZXh0TGVmdFBvcywgbmV4dFJpZ2h0UG9zLCB1cGRhdGVkUmFuZ2VzKTtcbiAgICB9XG4gIH1cblxuICBmaW5kTmV4dENoYW5nZShsZWZ0U3RhcnRQb3M9MCwgcmlnaHRTdGFydFBvcz0wKSB7XG4gICAgY29uc3QgbEFyciA9IHRoaXMubGVmdC5zbGljZShsZWZ0U3RhcnRQb3MpIHx8IFtdO1xuICAgIGNvbnN0IHJBcnIgPSB0aGlzLnJpZ2h0LnNsaWNlKHJpZ2h0U3RhcnRQb3MpIHx8IFtdO1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMubWlzbWF0Y2hPZmZzZXQobEFyciwgckFycik7XG5cbiAgICByZXR1cm4gW2xlZnRTdGFydFBvcyArIG9mZnNldCwgcmlnaHRTdGFydFBvcyArIG9mZnNldF07XG4gIH1cblxuICBmaW5kUHJldkNoYW5nZShsZWZ0TG86IG51bWJlciwgcmlnaHRMbzogbnVtYmVyLFxuICAgICAgICAgICAgICAgICBsZWZ0SGk6IG51bWJlciwgcmlnaHRIaTogbnVtYmVyKSB7XG4gICAgaWYgKGxlZnRMbyA+IGxlZnRIaSB8fCByaWdodExvID4gcmlnaHRIaSkge1xuICAgICAgcmV0dXJuIFtsZWZ0TG8sIGxlZnRIaSwgcmlnaHRMbywgcmlnaHRIaV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxBcnIgPSB0aGlzLmxlZnQuc2xpY2UobGVmdExvLCBsZWZ0SGkgKyAxKS5yZXZlcnNlKCkgfHwgW107XG4gICAgICBjb25zdCByQXJyID0gdGhpcy5yaWdodC5zbGljZShyaWdodExvLCByaWdodEhpICsgMSkucmV2ZXJzZSgpIHx8IFtdO1xuXG4gICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm1pc21hdGNoT2Zmc2V0KGxBcnIsIHJBcnIpO1xuICAgICAgcmV0dXJuIFtsZWZ0TG8sIGxlZnRIaSAtIG9mZnNldCwgcmlnaHRMbywgcmlnaHRIaSAtIG9mZnNldF07XG4gICAgfVxuICB9XG5cbiAgbWlzbWF0Y2hPZmZzZXQobEFycjogc3RyaW5nW10sIHJBcnI6IHN0cmluZ1tdKSB7XG4gICAgY29uc3QgbWF4ID0gTWF0aC5tYXgobEFyci5sZW5ndGgsIHJBcnIubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICBpZiAobEFycltpXSAhPT0gckFycltpXSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5taW4obEFyci5sZW5ndGgsIHJBcnIubGVuZ3RoKTtcbiAgfVxuXG4gIGlkZW50aWZ5VW5pcXVlUG9zaXRpb25zKCkgOiBBcnJheTxVbmlxdWVQb3NpdGlvbnM+IHtcbiAgICBjb25zdCBsZWZ0VW5pcXVlcyA9IHRoaXMuZmluZFVuaXF1ZSh0aGlzLmxlZnQpO1xuICAgIGNvbnN0IHJpZ2h0VW5pcXVlcyA9IHRoaXMuZmluZFVuaXF1ZSh0aGlzLnJpZ2h0KTtcbiAgICBjb25zdCBsZWZ0S2V5cyA9IG5ldyBTZXQoLi4ubGVmdFVuaXF1ZXMua2V5cygpKTtcbiAgICBjb25zdCByaWdodEtleXMgPSBuZXcgU2V0KC4uLnJpZ2h0VW5pcXVlcy5rZXlzKCkpO1xuICAgIGNvbnN0IHNoYXJlZEtleXMgPSBuZXcgU2V0KFsuLi5sZWZ0S2V5c10uZmlsdGVyKGsgPT4gcmlnaHRLZXlzLmhhcyhrKSkpO1xuXG4gICAgY29uc3QgdW5pcVJhbmdlcyA9IFsuLi5zaGFyZWRLZXlzXS5tYXAoKGspID0+IHtcbiAgICAgIHJldHVybiA8VW5pcXVlUG9zaXRpb25zPltsZWZ0VW5pcXVlcy5nZXQoayksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRVbmlxdWVzLmdldChrKV07XG4gICAgfSk7XG4gICAgdW5pcVJhbmdlcy51bnNoaWZ0KFt0aGlzLmxlZnQubGVuZ3RoLCB0aGlzLnJpZ2h0Lmxlbmd0aF0pO1xuICAgIHJldHVybiB1bmlxUmFuZ2VzO1xuICB9XG5cbiAgZmluZFVuaXF1ZShhcnJheTogc3RyaW5nW10pIHtcbiAgICBjb25zdCBmbGFnZ2VkVW5pcXVlczogTWFwPHN0cmluZywgVW5pcXVlSXRlbT4gPSBuZXcgTWFwPHN0cmluZywgVW5pcXVlSXRlbT4oKTtcblxuICAgIGFycmF5LmZvckVhY2goKGl0ZW0sIHBvcykgPT4ge1xuICAgICAgZmxhZ2dlZFVuaXF1ZXMuc2V0KGl0ZW0sIG5ldyBVbmlxdWVJdGVtKHBvcywgIWZsYWdnZWRVbmlxdWVzLmhhcyhpdGVtKSkpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdW5pcXVlcyA6IE1hcDxzdHJpbmcsIG51bWJlcj4gPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuICAgIGZvcihsZXQgW2tleSwgdmFsdWVdIG9mIGZsYWdnZWRVbmlxdWVzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKHZhbHVlLnVuaXF1ZSkge1xuICAgICAgICB1bmlxdWVzLnNldChrZXksIHZhbHVlLnBvcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXF1ZXM7XG4gIH1cblxuICAvLyBnaXZlbiB0aGUgY2FsY3VsYXRlZCBib3VuZHMgb2YgdGhlIDIgd2F5IGRpZmYsIGNyZWF0ZSB0aGUgcHJvcGVyXG4gIC8vIGNoYW5nZSB0eXBlIGFuZCBhZGQgaXQgdG8gdGhlIHF1ZXVlLlxuICBhcHBlbmRDaGFuZ2VSYW5nZShjaGFuZ2VzUmFuZ2VzOiBDaGFuZ2VSYW5nZVtdLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0TG86IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgbGVmdEhpOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0TG86IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRIaTogbnVtYmVyKSB7XG4gICAgaWYgKGxlZnRMbyA8PSBsZWZ0SGkgJiYgcmlnaHRMbyA8PSByaWdodEhpKSB7XG4gICAgICAvLyBmb3IgdGhpcyBjaGFuZ2UsIHRoZSBib3VuZHMgYXJlIGJvdGggJ25vcm1hbCcuIHRoZSBiZWdpbm5pbmdcbiAgICAgIC8vIG9mIHRoZSBjaGFuZ2UgaXMgYmVmb3JlIHRoZSBlbmQuXG4gICAgICBjaGFuZ2VzUmFuZ2VzLnB1c2gobmV3IENoYW5nZVJhbmdlKEFjdGlvbi5jaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRMbyArIDEsIGxlZnRIaSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0TG8gKyAxLCByaWdodEhpICsgMSkpO1xuICAgIH0gZWxzZSBpZiAobGVmdExvIDw9IGxlZnRIaSkge1xuICAgICAgY2hhbmdlc1Jhbmdlcy5wdXNoKG5ldyBDaGFuZ2VSYW5nZShBY3Rpb24ucmVtb3ZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0TG8gKyAxLCBsZWZ0SGkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodExvICsgMSwgcmlnaHRMbykpO1xuICAgIH0gZWxzZSBpZiAocmlnaHRMbyA8PSByaWdodEhpKSB7XG4gICAgICBjaGFuZ2VzUmFuZ2VzLnB1c2gobmV3IENoYW5nZVJhbmdlKEFjdGlvbi5hZGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRMbyArIDEsIGxlZnRMbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRMbyArIDEsIHJpZ2h0SGkgKyAxKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZXNSYW5nZXM7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgVW5pcXVlUG9zaXRpb25zID0gW251bWJlciwgbnVtYmVyXTtcblxuY2xhc3MgVW5pcXVlSXRlbSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwb3M6IG51bWJlciwgcHVibGljIHVuaXF1ZTogYm9vbGVhbikge31cbn1cblxuZXhwb3J0IGNsYXNzIFRleHROb2RlIHtcbiAgY29uc3RydWN0b3IocHVibGljIHRleHQ6IHN0cmluZywgcHVibGljIGxvdzogbnVtYmVyKSB7fVxufVxuXG5jbGFzcyBIZWNrZWxEaWZmV3JhcHBlciB7XG4gIG9sZFRleHQ6IEFycmF5PFRleHROb2RlfHN0cmluZz47XG4gIG5ld1RleHQ6IEFycmF5PFRleHROb2RlfHN0cmluZz47XG5cbiAgY29uc3RydWN0b3IocHVibGljIG9sZFRleHRBcnJheTogc3RyaW5nW10sXG4gICAgICAgICAgICAgIHB1YmxpYyBuZXdUZXh0QXJyYXk6IHN0cmluZ1tdLFxuICAgICAgICAgICAgICBwdWJsaWMgY2h1bmtzOiBDaGFuZ2VSYW5nZVtdKSB7XG4gICAgdGhpcy5vbGRUZXh0ID0gW107XG4gICAgdGhpcy5uZXdUZXh0ID0gW107XG4gIH1cblxuICBjb252ZXJ0VG9UeXBlZE91dHB1dCgpIHtcbiAgICBsZXQgZmluYWxJbmRleGVzID0gbmV3IEluZGV4VHJhY2tlcigwLCAwKTtcbiAgICB0aGlzLmNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4ge1xuICAgICAgY29uc3QgW29sZEl0ZXJhdGlvbiwgbmV3SXRlcmF0aW9uXSA9IHRoaXMuc2V0VGV4dE5vZGVJbmRleGVzKGNodW5rLCBmaW5hbEluZGV4ZXMub2xkSW5kZXgsIGZpbmFsSW5kZXhlcy5uZXdJbmRleCk7XG4gICAgICBjb25zdCBbb2xkSW5kZXgsIG5ld0luZGV4XSA9IHRoaXMuYXBwZW5kQ2hhbmdlcyhjaHVuaywgZmluYWxJbmRleGVzLm9sZEluZGV4ICsgb2xkSXRlcmF0aW9uLCBmaW5hbEluZGV4ZXMubmV3SW5kZXggKyBuZXdJdGVyYXRpb24pO1xuICAgICAgZmluYWxJbmRleGVzLm9sZEluZGV4ID0gb2xkSW5kZXg7XG4gICAgICBmaW5hbEluZGV4ZXMubmV3SW5kZXggPSBuZXdJbmRleDtcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0VGhlUmVtYWluaW5nVGV4dE5vZGVJbmRleGVzKGZpbmFsSW5kZXhlcy5vbGRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEluZGV4ZXMubmV3SW5kZXgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9sZFRleHQ6IHRoaXMub2xkVGV4dCxcbiAgICAgIG5ld1RleHQ6IHRoaXMubmV3VGV4dFxuICAgIH07XG4gIH1cblxuICBzZXRUZXh0Tm9kZUluZGV4ZXMoY2h1bms6IENoYW5nZVJhbmdlLCBvbGRJbmRleDogbnVtYmVyLCBuZXdJbmRleDogbnVtYmVyKSB7XG4gICAgbGV0IG9sZEl0ZXJhdGlvbiA9IDA7XG4gICAgd2hpbGUgKG9sZEluZGV4ICsgb2xkSXRlcmF0aW9uIDwgY2h1bmsubGVmdExvIC0gMSkgeyAvLyBjaHVuayBpbmRleGVzIGZyb20gMVxuICAgICAgdGhpcy5vbGRUZXh0LnB1c2gobmV3IFRleHROb2RlKHRoaXMub2xkVGV4dEFycmF5W29sZEluZGV4ICsgb2xkSXRlcmF0aW9uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbmRleCArIG9sZEl0ZXJhdGlvbikpO1xuICAgICAgb2xkSXRlcmF0aW9uICs9IDE7XG4gICAgfVxuXG4gICAgbGV0IG5ld0l0ZXJhdGlvbiA9IDA7XG4gICAgd2hpbGUgKG5ld0luZGV4ICsgbmV3SXRlcmF0aW9uIDwgY2h1bmsucmlnaHRMbyAtIDEpIHtcbiAgICAgIHRoaXMubmV3VGV4dC5wdXNoKG5ldyBUZXh0Tm9kZSh0aGlzLm5ld1RleHRBcnJheVtuZXdJbmRleCArIG5ld0l0ZXJhdGlvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkSW5kZXggKyBuZXdJdGVyYXRpb24pKTtcbiAgICAgIG5ld0l0ZXJhdGlvbiArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBbb2xkSXRlcmF0aW9uLCBuZXdJdGVyYXRpb25dO1xuICB9XG5cbiAgYXBwZW5kQ2hhbmdlcyhjaHVuazogQ2hhbmdlUmFuZ2UsIG9sZEluZGV4OiBudW1iZXIsIG5ld0luZGV4OiBudW1iZXIpIHtcbiAgICB3aGlsZSAob2xkSW5kZXggPD0gY2h1bmsubGVmdEhpIC0gMSkge1xuICAgICAgdGhpcy5vbGRUZXh0LnB1c2godGhpcy5vbGRUZXh0QXJyYXlbb2xkSW5kZXhdKTtcbiAgICAgIG9sZEluZGV4ICs9IDE7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5ld0luZGV4IDw9IGNodW5rLnJpZ2h0SGkgLSAxKSB7XG4gICAgICB0aGlzLm5ld1RleHQucHVzaCh0aGlzLm5ld1RleHRBcnJheVtuZXdJbmRleF0pO1xuICAgICAgbmV3SW5kZXggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIFtvbGRJbmRleCwgbmV3SW5kZXhdO1xuICB9XG5cbiAgc2V0VGhlUmVtYWluaW5nVGV4dE5vZGVJbmRleGVzKG9sZEluZGV4OiBudW1iZXIsIG5ld0luZGV4OiBudW1iZXIpIHtcbiAgICBsZXQgaXRlcmF0aW9uID0gMDtcbiAgICB3aGlsZSAob2xkSW5kZXggKyBpdGVyYXRpb24gPCB0aGlzLm9sZFRleHRBcnJheS5sZW5ndGgpIHtcbiAgICAgIHRoaXMub2xkVGV4dC5wdXNoKG5ldyBUZXh0Tm9kZSh0aGlzLm9sZFRleHRBcnJheVtvbGRJbmRleCArIGl0ZXJhdGlvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXggKyBpdGVyYXRpb24pKTtcbiAgICAgIGl0ZXJhdGlvbiArPSAxO1xuICAgIH1cblxuICAgIHdoaWxlIChuZXdJbmRleCArIGl0ZXJhdGlvbiA8IHRoaXMubmV3VGV4dEFycmF5Lmxlbmd0aCkge1xuICAgICAgdGhpcy5uZXdUZXh0LnB1c2gobmV3IFRleHROb2RlKHRoaXMubmV3VGV4dEFycmF5W25ld0luZGV4ICsgaXRlcmF0aW9uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRJbmRleCArIGl0ZXJhdGlvbikpO1xuICAgICAgaXRlcmF0aW9uICs9IDE7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEluZGV4VHJhY2tlciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBvbGRJbmRleDogbnVtYmVyLCBwdWJsaWMgbmV3SW5kZXg6IG51bWJlcikge1xuICB9XG59XG5cbmV4cG9ydCBlbnVtIEFjdGlvbiB7XG4gIGNoYW5nZSA9IFwiY2hhbmdlXCIsXG4gIGFkZCA9IFwiYWRkXCIsXG4gIHJlbW92ZSA9IFwicmVtb3ZlXCJcbn1cblxuZXhwb3J0IGNsYXNzIENoYW5nZVJhbmdlIHtcbiAgY29uc3RydWN0b3IocHVibGljIGFjdGlvbjogQWN0aW9uLFxuICAgICAgICAgICAgICBwdWJsaWMgbGVmdExvOiBudW1iZXIsIHB1YmxpYyBsZWZ0SGk6IG51bWJlcixcbiAgICAgICAgICAgICAgcHVibGljIHJpZ2h0TG86IG51bWJlciwgcHVibGljIHJpZ2h0SGk6IG51bWJlcikge31cbn1cblxuZXhwb3J0IGNsYXNzIENoYW5nZURhdGEge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgbGVmdENoYW5nZVBvczogbnVtYmVyLFxuICAgICAgICAgICAgICBwdWJsaWMgcmlnaHRDaGFuZ2VQb3M6IG51bWJlcixcbiAgICAgICAgICAgICAgcHVibGljIGNoYW5nZVJhbmdlczogQ2hhbmdlUmFuZ2VbXSkge1xuICB9XG59XG4iXX0=